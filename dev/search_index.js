var documenterSearchIndex = {"docs":
[{"location":"Operators/#Differentiation-Operators","page":"Differentiation Operators","title":"Differentiation Operators","text":"","category":"section"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"DerivableFunctions.jl aims to provide a backend-agnostic interface for differentiation and currently allows the user to seamlessly switch between ForwardDiff.jl, ReverseDiff.jl, Zygote.jl, FiniteDifferences.jl and Symbolics.jl.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"The desired backend is optionally specified in the first argument (default is ForwardDiff) via a Symbol or Val. The available backends can be listed via diff_backends().","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Next, the function that is to be differentiated is provided. We will illustrate this syntax using the GetMatrixJac method:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"using DerivableFunctions\nMetric(x) = [exp(x[1]^3) sin(cosh(x[2])); log(sqrt(x[1])) x[1]^2*x[2]^5]\nJac = GetMatrixJac(Val(:ForwardDiff), Metric)\nJac([1,2.])","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Moreover, these operators are overloaded to allow for passthrough of symbolic variables.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"using Symbolics\n@variables z[1:2]\nJ = Jac(z)\nJ[:,:,1], J[:,:,2]","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Since the function Metric in this example can be represented in terms of analytic expressions, it is also possible to construct its derivative symbolically:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"SymJac = GetMatrixJac(Val(:Symbolic), Metric)\nSymJac([1,2.])","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Currently, DerivableFunctions.jl exports GetDeriv(), GetGrad(), GetHess(), GetJac(), GetDoubleJac() and GetMatrixJac().","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Furthermore, these operators also have in-place versions:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Jac! = GetMatrixJac!(Val(:ForwardDiff), Metric)\nY = Array{Float64}(undef, 2, 2, 2)\nJac!(Y, [1,2.])","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Just like the out-of-place versions, the in-place operators are overloaded for symbolic passthrough:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Ynum = Array{Num}(undef, 2, 2, 2)\nJac!(Ynum, z)\nYnum[:,:,1], Ynum[:,:,2]","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"The exported in-place operators include GetGrad!(), GetHess!(), GetJac!() and GetMatrixJac!().","category":"page"},{"location":"DFunctions/#DFunctions","page":"DFunctions","title":"DFunctions","text":"","category":"section"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"The DFunction type stores the first and second derivatives of a given input function which is not only convenient but can enhance performance significantly. At this point, the DFunction type requires the given function to be out-of-place, however, this will likely be extended to in-place functions in the future.","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"Once constructed, a DFunction object D can be evaluated at x via the syntax EvalF(D,x), EvaldF(D,x) and EvalddF(D,x).","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"In order to construct the appropriate derivatives, the input and output dimensions of a given function F are assessed and the appropriate operators (GetGrad(), GetJac() and so on) called.","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"By default, DFunction() attempts to construct the derivatives symbolically, however, this can be specified via the ADmode keyword:","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"using DerivableFunctions\n\nD = DFunction(x->[x^7 - sin(x), tanh(x)]; ADmode=Val(:ReverseDiff))\nEvalF(D, 5.), EvaldF(D, 5.), EvalddF(D, 5.)\n\nusing Symbolics;  @variables y\nEvalF(D, y), EvaldF(D, y), EvalddF(D, y)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DerivableFunctions","category":"page"},{"location":"#DerivableFunctions","page":"Home","title":"DerivableFunctions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DerivableFunctions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DerivableFunctions]","category":"page"},{"location":"#DerivableFunctions.DerivableFunction","page":"Home","title":"DerivableFunctions.DerivableFunction","text":"DerivableFunction(F::Function; ADmode::Union{Val,Symbol}=Val(:Symbolic))\nDerivableFunction(F::Function, testinput::Union{Number,AbstractVector{<:Number}}; ADmode::Union{Val,Symbol}=Val(:Symbolic))\nDerivableFunction(F::Function, dF::Function; ADmode::Union{Val,Symbol}=Val(:Symbolic))\nDerivableFunction(F::Function, dF::Function, ddF::Function)\n\nStores derivatives of a given function (as well as input-output dimensions) for potentially faster computations when derivatives are known.\n\n\n\n\n\n","category":"type"},{"location":"#DerivableFunctions.Builder-Tuple{Union{Symbolics.Num, AbstractArray{var\"#s103\", N} where {var\"#s103\"<:Symbolics.Num, N}}, Vararg{Any, N} where N}","page":"Home","title":"DerivableFunctions.Builder","text":"Builder(Fexpr::Union{<:AbstractVector{<:Num},<:Num}, args...; inplace::Bool=false, parallel::Bool=false, kwargs...)\n\nBuilds RuntimeGeneratedFunctions from expressions via build_function().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetArgLength-Tuple{Function}","page":"Home","title":"DerivableFunctions.GetArgLength","text":"GetArgLength(F::Function; max::Int=100) -> Int\n\nAttempts to determine input structure of F, i.e. whether it accepts Numbers or AbstractVectors and of what length. This is achieved by successively evaluating the function on rand(i) until the evaluation no longer throws errors. As a result, GetArgLength will be unable to determine the correct input structure if F errors on rand(i).\n\nnote: Note\nDoes NOT discriminate between Real and Vector{Real} of length one, i.e. Real↦+1. To disciminate between these two options, use DerivableFunctions._GetArgLength instead.\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetDeriv-Tuple{Val, Function, Vararg{Any, N} where N}","page":"Home","title":"DerivableFunctions.GetDeriv","text":"GetDeriv(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes the scalar derivative of F out-of-place via a backend specified by ADmode.\n\nExample:\n\nDerivative = GetDeriv(Val(:ForwardDiff), x->exp(-x^2))\nDerivative(5.0)\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetDoubleJac","page":"Home","title":"DerivableFunctions.GetDoubleJac","text":"GetDoubleJac(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes the Jacobian of the Jacobian for a vector-valued function F out-of-place via a backend specified by ADmode.\n\nExample:\n\nDoubleJacobian = GetDoubleJac(Val(:ForwardDiff), x->[x[1]^2, x[1]*x[2]^3])\nDoubleJacobian(rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"function"},{"location":"#DerivableFunctions.GetGrad!-Tuple{Val, Function}","page":"Home","title":"DerivableFunctions.GetGrad!","text":"GetGrad!(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes gradients in-place via a backend specified by ADmode. The function returned by GetGrad! has argument structure (Y::AbstractVector, X::AbstractVector) where the gradient of F evaluated at X is saved into Y.\n\nExample:\n\nGradient! = GetGrad!(Val(:ForwardDiff), x->x[1]^2 - x[2]^3)\nY = Vector{Float64}(undef, 2)\nGradient!(Y, rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetGrad-Tuple{Val, Function, Vararg{Any, N} where N}","page":"Home","title":"DerivableFunctions.GetGrad","text":"GetGrad(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes the gradient of F out-of-place via a backend specified by ADmode.\n\nExample:\n\nGradient = GetGrad(Val(:ForwardDiff), x->x[1]^2 - x[2]^3)\nGradient(rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetHess!-Tuple{Val, Function}","page":"Home","title":"DerivableFunctions.GetHess!","text":"GetHess!(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes Hessians in-place via a backend specified by ADmode. The function returned by GetHess! has argument structure (Y::AbstractMatrix, X::AbstractVector) where the Hessian of F evaluated at X is saved into Y.\n\nExample:\n\nHessian! = GetHess!(Val(:ForwardDiff), x->x[1]^2 -x[2]^3 + x[1]*x[2])\nY = Matrix{Float64}(undef, 2, 2)\nHessian!(Y, rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetHess-Tuple{Val, Function, Vararg{Any, N} where N}","page":"Home","title":"DerivableFunctions.GetHess","text":"GetHess(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes the Hessian of F out-of-place via a backend specified by ADmode.\n\nExample:\n\nHessian = GetHess(Val(:ForwardDiff), x->x[1]^2 -x[2]^3 + x[1]*x[2])\nHessian(rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetJac!-Tuple{Val, Function}","page":"Home","title":"DerivableFunctions.GetJac!","text":"GetJac!(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes Jacobians in-place via a backend specified by ADmode. The function returned by GetJac! has argument structure (Y::AbstractMatrix, X::AbstractVector) where the Jacobian of F evaluated at X is saved into Y.\n\nExample:\n\nJacobian! = GetJac!(Val(:ForwardDiff), x->[x[1]^2, -x[2]^3, x[1]*x[2]])\nY = Matrix{Float64}(undef, 3, 2)\nJacobian!(Y, rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetJac-Tuple{Val, Function, Vararg{Any, N} where N}","page":"Home","title":"DerivableFunctions.GetJac","text":"GetJac(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes the Jacobian of F out-of-place via a backend specified by ADmode.\n\nExample:\n\nJacobian = GetJac(Val(:ForwardDiff), x->[x[1]^2, -x[2]^3, x[1]*x[2]])\nJacobian(rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetMatrixJac","page":"Home","title":"DerivableFunctions.GetMatrixJac","text":"GetMatrixJac(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes the Jacobian of an array-valued function F out-of-place via a backend specified by ADmode.\n\nExample:\n\nJacobian = GetMatrixJac(Val(:ForwardDiff), x->[x[1]^2 x[2]^3; x[1]*x[2] 2])\nJacobian(rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"function"},{"location":"#DerivableFunctions.GetMatrixJac!-Tuple{Val, Function}","page":"Home","title":"DerivableFunctions.GetMatrixJac!","text":"GetMatrixJac!(ADmode::Val, F::Function; kwargs...) -> Function\n\nReturns a function which computes Jacobians in-place for array-valued functions via a backend specified by ADmode. The function returned by GetMatrixJac! has argument structure (Y::AbstractArray, X::AbstractVector) where the Jacobian of F evaluated at X is saved into Y.\n\nExample:\n\nJacobian! = GetMatrixJac!(Val(:ForwardDiff), x->[x[1]^2 x[2]^3; x[1]*x[2] 2])\nY = Array{Float64}(undef, 2, 2, 2)\nJacobian!(Y, rand(2))\n\nFor available backends, see diff_backends().\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetOutLength-Tuple{Function, Union{Number, AbstractVector{var\"#s107\"} where var\"#s107\"<:Number}}","page":"Home","title":"DerivableFunctions.GetOutLength","text":"GetOutLength(F::Function, input::Union{Number,AbstractVector{<:Number}})\n\nReturns output dimensions of given F. If it outputs arrays of more than one dimension, a tuple is returned. This can also be used to determine the approximate size of the input for mutating F which accept 2 arguments.\n\nnote: Note\nDiscriminates between Real and Vector{Real} of length one, i.e.: Real↦-1 and x::AbstractVector{<:Real}↦length(x).\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.GetSymbolicDerivative","page":"Home","title":"DerivableFunctions.GetSymbolicDerivative","text":"GetSymbolicDerivative(F::Function, inputdim::Int=GetArgLength(F), deriv::Symbol=:jacobian; timeout::Real=5, inplace::Bool=false, parallel::Bool=false)\n\nComputes symbolic derivatives, including :jacobian, :gradient, :hessian and :derivative which are specified via deriv. Special care has to be taken that the correct inputdim is specified! Silent errors may occur otherwise.\n\n\n\n\n\n","category":"function"},{"location":"#DerivableFunctions.KillAfter-Tuple{Function, Vararg{Any, N} where N}","page":"Home","title":"DerivableFunctions.KillAfter","text":"KillAfter(F::Function, args...; timeout::Real=5, verbose::Bool=false, kwargs...)\n\nTries to evaluate a given function F before a set timeout limit is reached and interrupts the evaluation and returns nothing if necessary. NOTE: The given function is evaluated via F(args...; kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.MaximalNumberOfArguments-Tuple{Function}","page":"Home","title":"DerivableFunctions.MaximalNumberOfArguments","text":"MaximalNumberOfArguments(F::Function) -> Int\n\nInfers argument structure of given function, i.e. whether it is of the form F(x) or F(x,y) or F(x,y,z) etc. and returns maximal number of accepted arguments of all overloads of F as integer.\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.SymbolicPassthrough","page":"Home","title":"DerivableFunctions.SymbolicPassthrough","text":"Executes symbolic derivative as specified by deriv::Symbol.\n\n\n\n\n\n","category":"function"},{"location":"#DerivableFunctions._GetArgLength-Tuple{Function}","page":"Home","title":"DerivableFunctions._GetArgLength","text":"_GetArgLength(F::Function; max::Int=100) -> Int\n\nnote: Note\nDiscriminates between Real and Vector{Real} of length one, i.e.: Real↦-1 and x::AbstractVector{<:Real}↦length(x).\n\n\n\n\n\n","category":"method"},{"location":"#DerivableFunctions.suff-Tuple{BigFloat}","page":"Home","title":"DerivableFunctions.suff","text":"suff(x) -> Type\n\nIf x stores BigFloats, suff returns BigFloat, else suff returns Float64.\n\n\n\n\n\n","category":"method"}]
}
