var documenterSearchIndex = {"docs":
[{"location":"Operators/#Differentiation-Operators","page":"Differentiation Operators","title":"Differentiation Operators","text":"","category":"section"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"DerivableFunctions.jl aims to provide a backend-agnostic interface for differentiation and currently allows the user to seamlessly switch between ForwardDiff.jl, ReverseDiff.jl, Zygote.jl, FiniteDifferences.jl and Symbolics.jl.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"The desired backend is optionally specified in the first argument (default is ForwardDiff) via a Symbol or Val. The available backends can be listed via diff_backends().","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Next, the function that is to be differentiated is provided. We will illustrate this syntax using the GetMatrixJac method:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"using DerivableFunctions\nMetric(x) = [exp(x[1]^3) sin(cosh(x[2])); log(sqrt(x[1])) x[1]^2*x[2]^5]\nJac = GetMatrixJac(Val(:ForwardDiff), Metric)\nJac([1,2.])","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Moreover, these operators are overloaded to allow for passthrough of symbolic variables.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"using Symbolics\n@variables z[1:2]\nJ = Jac(z)\nJ[:,:,1], J[:,:,2]","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Since the function Metric in this example can be represented in terms of analytic expressions, it is also possible to construct its derivative symbolically:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"SymJac = GetMatrixJac(Val(:Symbolic), Metric)\nSymJac([1,2.])","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Currently, DerivableFunctions.jl exports GetDeriv(), GetGrad(), GetHess(), GetJac(), GetDoubleJac() and GetMatrixJac().","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Furthermore, these operators also have in-place versions:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Jac! = GetMatrixJac!(Val(:ForwardDiff), Metric)\nY = Array{Float64}(undef, 2, 2, 2)\nJac!(Y, [1,2.])","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Just like the out-of-place versions, the in-place operators are overloaded for symbolic passthrough:","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Ynum = Array{Num}(undef, 2, 2, 2)\nJac!(Ynum, z)\nYnum[:,:,1], Ynum[:,:,2]","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"The exported in-place operators include GetGrad!(), GetHess!(), GetJac!() and GetMatrixJac!().","category":"page"},{"location":"Operators/#Differentiation-Backend-Agnostic-Programming","page":"Differentiation Operators","title":"Differentiation Backend-Agnostic Programming","text":"","category":"section"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Essentially, the abstraction layer provided by DerivableFunctions.jl only requires the user to specify the \"semantic\" meaning of a given differentiation operation while allowing for flexible post hoc choice of backend as well as enabling symbolic pass through for the resulting computation.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"For example, when calculating differential-geometric quantities such as the Riemann or Ricci tensors, which depend on complicated combinations of up to second derivatives of the components of the metric tensor, a single implementation simultaneously provides a performant numerical implementation as well as allowing for analytical insight for simple examples.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"using DerivableFunctions, Tullio, LinearAlgebra\nMetricPartials(Metric::Function, θ::AbstractVector; ADmode::Val=Val(:ForwardDiff)) = GetMatrixJac(ADmode, Metric)(θ)\nfunction ChristoffelSymbol(Metric::Function, θ::AbstractVector; ADmode::Val=Val(:ForwardDiff))\n  PDV = MetricPartials(Metric, θ; ADmode);  InvMetric = inv(Metric(θ))\n  @tullio Γ[a,i,j] := ((1/2) * InvMetric)[a,m] * (PDV[j,m,i] + PDV[m,i,j] - PDV[i,j,m])\nend\nfunction ChristoffelPartials(Metric::Function, θ::AbstractVector; ADmode::Val=Val(:ForwardDiff))\n  GetMatrixJac(ADmode, x->ChristoffelSymbol(Metric, x; ADmode))(θ)\nend\nfunction Riemann(Metric::Function, θ::AbstractVector; ADmode::Val=Val(:ForwardDiff))\n  Γ = ChristoffelSymbol(Metric, θ; ADmode)\n  ∂Γ = ChristoffelPartials(Metric, θ; ADmode)\n  @tullio Riem[i,j,k,l] := ∂Γ[i,j,l,k] - ∂Γ[i,j,k,l]\n  @tullio Riem[i,j,k,l] += Γ[i,a,k]*Γ[a,j,l] - Γ[i,a,l]*Γ[a,j,k]\nend\nfunction Ricci(Metric::Function, θ::AbstractVector; ADmode::Val=Val(:ForwardDiff))\n  Riem = Riemann(Metric, θ; ADmode)\n  @tullio Ric[a,b] := Riem[s,a,s,b]\nend\nfunction RicciScalar(Metric::Function, θ::AbstractVector; ADmode::Val=Val(:ForwardDiff))\n  InvMetric = inv(Metric(θ))\n  tr(transpose(Ricci(Metric, θ; ADmode)) * InvMetric)\nend","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Clearly, this simplified implementation features some redundant evaluations of the inverse metric and could be made more efficient. Nevertheless, it nicely illustrates how succinctly complex real-world examples can be formulated.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"Given the metric tensor induced by the canonical embedding of S^2 into mathbbR^3 with spherical coordinates, it can be shown that the Ricci scalar assumes a constant value of R=2 everywhere on S^2.","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"S2metric((θ,ϕ)) = [1.0 0; 0 sin(θ)^2]\n2 ≈ RicciScalar(S2metric, rand(2); ADmode=Val(:ForwardDiff)) ≈ RicciScalar(S2metric, rand(2); ADmode=Val(:ReverseDiff))","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"(In this particular instance, due to a term in the ChristoffelSymbol where the sin in the numerator does not cancel with the identical term in the denominator, the symbolic computation does not recognize the fact that the final expression can be simplified to yield exactly R=2.)","category":"page"},{"location":"Operators/","page":"Differentiation Operators","title":"Differentiation Operators","text":"using Symbolics;  @variables p[1:2]\nRicciScalar(S2metric, p)","category":"page"},{"location":"DFunctions/#DFunctions","page":"DFunctions","title":"DFunctions","text":"","category":"section"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"The DFunction type stores the first and second derivatives of a given input function which is not only convenient but can enhance performance significantly. At this point, the DFunction type requires the given function to be out-of-place, however, this will likely be extended to in-place functions in the future.","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"Once constructed, a DFunction object D can be evaluated at x via the syntax EvalF(D,x), EvaldF(D,x) and EvalddF(D,x).","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"In order to construct the appropriate derivatives, the input and output dimensions of a given function F are assessed and the appropriate operators (GetGrad(), GetJac() and so on) called.","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"By default, DFunction() attempts to construct the derivatives symbolically, however, this can be specified via the ADmode keyword:","category":"page"},{"location":"DFunctions/","page":"DFunctions","title":"DFunctions","text":"using DerivableFunctions\n\nD = DFunction(x->[x^7 - sin(x), tanh(x)]; ADmode=Val(:ReverseDiff))\nEvalF(D, 5.), EvaldF(D, 5.), EvalddF(D, 5.)\n\nusing Symbolics;  @variables y\nEvalF(D, y), EvaldF(D, y), EvalddF(D, y)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DerivableFunctions","category":"page"},{"location":"#DerivableFunctions","page":"Home","title":"DerivableFunctions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for DerivableFunctions.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [DerivableFunctions]","category":"page"}]
}
